import argparse
import logging
from pathlib import Path
import re
import sys
from typing import Any, Dict, Tuple

from .common import Entity, Variable
from .util import get_connector_name


def parse_entities(vhdl_src: str) -> Tuple[str, Dict[str, Entity]]:
    entity_dict = {}
    target_entity = None

    reading = False
    for line in vhdl_src.split('\n'):
        if line.startswith(f'entity'):
            target_entity = line.split(' ')[1]
            reading = True
        elif line.startswith(f'end {target_entity};'):
            break
        elif reading is True:
            trim_line = line.strip()
            # Ignore non-variable lines
            if trim_line.startswith('port (') or trim_line.startswith(');'):
                pass
            else:
                entity_obj = Entity()
                #print(f'Parsing variable info from:\n\t{trim_line}')
                # Variable Name
                port_name, port_type = trim_line.split(':')
                entity_obj.port_name = port_name.strip()

                # Variable Type
                if 'in ' in port_type:
                    entity_obj.direction = Variable.Direction.IN
                else:
                    entity_obj.direction = Variable.Direction.OUT

                # Variable Type
                if 'std_logic_vector' in port_type:
                    result = re.search('.*\((.*)\);', port_type)
                    first_bound, type_str, second_bound =  result.group(1).split(' ')

                    entity_obj.var_type = Variable.Type.VECTOR

                    if  'to' == type_str:
                        entity_obj.vector_type = Variable.VectorType.ASCENDING
                        entity_obj.vector_size = int(second_bound) - int(first_bound) + 1
                    elif 'downto' == type_str:
                        entity_obj.vector_type = Variable.VectorType.DESCENDING
                        entity_obj.vector_size = int(first_bound) - int(second_bound) + 1
                else:
                    entity_obj.var_type = Variable.Type.SCALAR
                entity_obj.name = get_connector_name(entity_obj)

                entity_dict[port_name] = entity_obj
                #print(f'{entity_obj}')

    return (target_entity, entity_dict)


def parse_args() -> Any:
    parser = argparse.ArgumentParser(
        prog="IP_Export",
        description="Tool to auto-generate verilog stubs for LabVIEW FPGA IP Exported IP"
    )
    parser.add_argument(
        "-v", "--verbose", default=False, action="store_true", help="Verbose"
    )
    parser.add_argument(
        "-d", "--debug", default=False, action="store_true", help="Debug"
    )
    parser.add_argument(
        "-s", "--source", default=None, action="store", type=str, help="Top-Level VHDL file generated by IP Export"
    )
    parser.add_argument(
        "-o", "--output-file", default="default_tb.v", help="Specify output file (Testbench file name)"
    )
    return parser.parse_args()


def main():
    args = parse_args()

    # Select source VHDL file
    vhdl_src = None
    if args.source is not None:
        vhdl_src = args.source
    else:
        print(f'Source VHDL file not specifed')
        print(f'  - Use -s/--source <vhdl file> to manually specify')
        print(f'  - Checking current directory...')
        pos_files = [x for x in Path('.').glob('NiFpga*.vhd')]
        if len(pos_files) == 1:
            print(f'  - Using {pos_files[0]}')
            vhdl_src = pos_files[0]
        else:
            print(f'  - More than one file matched, please run again with')
            print(f'    the -s/--source <vhdl file> parameter.')
            print(f'  - FYI, files that matched')
            print('    - ' + '    - '.join([ str(x) + '\n' for x in pos_files]))
            sys.exit(1)

    out_file = None
    if args.output_file is not None:
        out_file = args.output_file
    else:
        print(f'Output file not specified')
        print(f'  - Use -o/--output-file to manually specify.')
        print(f'  - Defaulting to {out_file}.')

    print(f'Parsing {vhdl_src} VHDL file.')
    print(f'Output will be saved to {out_file}.')

    tab_stop = '    '
    if not Path(vhdl_src).exists():
        print(f'File {vhdl_src} not found')
        sys.exit(1)

    (target_entity, entity_dict) = parse_entities(Path(vhdl_src).read_text())

    print(f'Detected the following ports:')
    for key, val in entity_dict.items():
        print(f'  - {key}')

    out_str = ''
    # Generate code for instantiating this ip
    # First reg/wire declarations
    #  - reg for input
    #  - wire for output
    out_str += f'    // Variables for {target_entity}\n'
    for key, val in entity_dict.items():
        line_str = "    "
        if val.direction == Variable.Direction.IN:
            line_str += "reg    "
        elif val.direction == Variable.Direction.OUT:
            line_str += "wire   "
        if val.var_type == Variable.Type.VECTOR:
            line_str += f'[{val.vector_size-1:2}:0] '
        else:
            line_str += ' ' * 7
        line_str += f'   {val.name};'

        out_str += f'{line_str}\n'

    # Then UUT and wire it up
    out_str += '\n'
    out_str += f'{tab_stop}{target_entity} UUT (\n'
    # key is port/signal name
    for idx, (key, val) in enumerate(entity_dict.items()):
        tail = ','
        if idx + 1 == len(entity_dict.items()):
            tail = ''
        out_str += f'{tab_stop*2}.{val.port_name}({val.name}){tail}\n'
    out_str += f'{tab_stop});\n'
    out_str += f'{tab_stop}// AUTO_GENERATED_CODE_END: parse.py\n'
    print('-' * 80)
#    print(f'{out_str}')
    print(f'{__file__}')

if __file__ == "__main__":
    main()
